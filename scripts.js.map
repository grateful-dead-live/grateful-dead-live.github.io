{"version":3,"sources":["node_modules/fuse.js/dist/fuse.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,qBAAqB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;;AAEnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO,EAAE;;AAET;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,qBAAqB;;AAErB,6CAA6C,SAAS;AACtD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB,kBAAkB,kBAAkB;;AAEtF,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uFAAuF;AACvF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;;AAEP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP,KAAK;AACL;AACA;AACA,oCAAoC;;AAEpC,4CAA4C,SAAS;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mBAAmB;AACnB;AACA;;AAEA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;AACA,sFAAsF;AACtF;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC;;AAEpC,8BAA8B;;AAE9B,oEAAoE;;AAEpE,qCAAqC;;AAErC,wCAAwC;;AAExC;;AAEA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;;;AAGP;AACA;AACA,wGAAwG;;AAExG;AACA;;AAEA,0BAA0B,YAAY;AACtC;AACA;;AAEA;AACA;AACA,SAAS;;;AAGT,yDAAyD;;AAEzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA,aAAa;;;AAGb;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA,sCAAsC;;AAEtC;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,yCAAyC,SAAS;AAClD,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;;AAGT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B,4CAA4C,UAAU;AACtD,mCAAmC;;AAEnC;AACA,yBAAyB;;AAEzB,kDAAkD,UAAU;AAC5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B,+BAA+B;AAC/B,KAAK;AACL,IAAI;AACJ;;;AAGA;AACA,sFAAsF;AACtF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,YAAY;;AAElD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yFAAyF;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,0BAA0B;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,eAAe;AACf,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,GAAG,GAAG;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,CAAC","file":"scripts.js","sourcesContent":["/**\n * Fuse.js v6.0.4 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2020 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.Fuse = factory());\n}(this, (function () { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _createSuper(Derived) {\n    return function () {\n      var Super = _getPrototypeOf(Derived),\n          result;\n\n      if (_isNativeReflectConstruct()) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function isArray(value) {\n    return !Array.isArray ? Object.prototype.toString.call(value) === '[object Array]' : Array.isArray(value);\n  } // Adapted from:\n  // https://github.com/lodash/lodash/blob/f4ca396a796435422bd4fd41fadbd225edddf175/.internal/baseToString.js\n\n  var INFINITY = 1 / 0;\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n\n    var result = value + '';\n    return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n  }\n  function toString(value) {\n    return value == null ? '' : baseToString(value);\n  }\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  function isNumber(value) {\n    return typeof value === 'number';\n  }\n  function isObject(value) {\n    return _typeof(value) === 'object';\n  }\n  function isDefined(value) {\n    return value !== undefined && value !== null;\n  }\n  function isBlank(value) {\n    return !value.trim().length;\n  }\n\n  var EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\n  var INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n  var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key) {\n    return \"Invalid value for key \".concat(key);\n  };\n  var PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE(max) {\n    return \"Pattern length exceeds max of \".concat(max, \".\");\n  };\n  var MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY(name) {\n    return \"Missing \".concat(name, \" property in key\");\n  };\n  var INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE(key) {\n    return \"Property 'weight' in key '\".concat(key, \"' must be a positive integer\");\n  };\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  var KeyStore = /*#__PURE__*/function () {\n    function KeyStore(keys) {\n      var _this = this;\n\n      _classCallCheck(this, KeyStore);\n\n      this._keys = {};\n      this._keyNames = [];\n      var totalWeight = 0;\n      keys.forEach(function (key) {\n        var keyName;\n        var weight = 1;\n\n        if (isString(key)) {\n          keyName = key;\n        } else {\n          if (!hasOwn.call(key, 'name')) {\n            throw new Error(MISSING_KEY_PROPERTY('name'));\n          }\n\n          keyName = key.name;\n\n          if (hasOwn.call(key, 'weight')) {\n            weight = key.weight;\n\n            if (weight <= 0) {\n              throw new Error(INVALID_KEY_WEIGHT_VALUE(keyName));\n            }\n          }\n        }\n\n        _this._keyNames.push(keyName);\n\n        _this._keys[keyName] = {\n          weight: weight\n        };\n        totalWeight += weight;\n      }); // Normalize weights so that their sum is equal to 1\n\n      this._keyNames.forEach(function (key) {\n        _this._keys[key].weight /= totalWeight;\n      });\n    }\n\n    _createClass(KeyStore, [{\n      key: \"get\",\n      value: function get(key, name) {\n        return this._keys[key] && this._keys[key][name];\n      }\n    }, {\n      key: \"keys\",\n      value: function keys() {\n        return this._keyNames;\n      }\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return JSON.stringify(this._keys);\n      }\n    }]);\n\n    return KeyStore;\n  }();\n\n  function get(obj, path) {\n    var list = [];\n    var arr = false;\n\n    var deepGet = function deepGet(obj, path) {\n      if (!path) {\n        // If there's no path left, we've arrived at the object we care about.\n        list.push(obj);\n      } else {\n        var dotIndex = path.indexOf('.');\n        var key = path;\n        var remaining = null;\n\n        if (dotIndex !== -1) {\n          key = path.slice(0, dotIndex);\n          remaining = path.slice(dotIndex + 1);\n        }\n\n        var value = obj[key];\n\n        if (!isDefined(value)) {\n          return;\n        }\n\n        if (!remaining && (isString(value) || isNumber(value))) {\n          list.push(toString(value));\n        } else if (isArray(value)) {\n          arr = true; // Search each item in the array.\n\n          for (var i = 0, len = value.length; i < len; i += 1) {\n            deepGet(value[i], remaining);\n          }\n        } else if (remaining) {\n          // An object. Recurse further.\n          deepGet(value, remaining);\n        }\n      }\n    };\n\n    deepGet(obj, path);\n    return arr ? list : list[0];\n  }\n\n  var MatchOptions = {\n    // Whether the matches should be included in the result set. When true, each record in the result\n    // set will include the indices of the matched characters.\n    // These can consequently be used for highlighting purposes.\n    includeMatches: false,\n    // When true, the matching function will continue to the end of a search pattern even if\n    // a perfect match has already been located in the string.\n    findAllMatches: false,\n    // Minimum number of characters that must be matched before a result is considered a match\n    minMatchCharLength: 1\n  };\n  var BasicOptions = {\n    // When true, the algorithm continues searching to the end of the input even if a perfect\n    // match is found before the end of the same input.\n    isCaseSensitive: false,\n    // When true, the matching function will continue to the end of a search pattern even if\n    includeScore: false,\n    // List of properties that will be searched. This also supports nested properties.\n    keys: [],\n    // Whether to sort the result list, by score\n    shouldSort: true,\n    // Default sort function: sort by ascending score, ascending index\n    sortFn: function sortFn(a, b) {\n      return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;\n    }\n  };\n  var FuzzyOptions = {\n    // Approximately where in the text is the pattern expected to be found?\n    location: 0,\n    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n    // (of both letters and location), a threshold of '1.0' would match anything.\n    threshold: 0.6,\n    // Determines how close the match must be to the fuzzy location (specified above).\n    // An exact letter match which is 'distance' characters away from the fuzzy location\n    // would score as a complete mismatch. A distance of '0' requires the match be at\n    // the exact location specified, a threshold of '1000' would require a perfect match\n    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n    distance: 100\n  };\n  var AdvancedOptions = {\n    // When true, it enables the use of unix-like search commands\n    useExtendedSearch: false,\n    // The get function to use when fetching an object's properties.\n    // The default will search nested paths *ie foo.bar.baz*\n    getFn: get\n  };\n  var Config = _objectSpread2({}, BasicOptions, {}, MatchOptions, {}, FuzzyOptions, {}, AdvancedOptions);\n\n  var SPACE = /[^ ]+/g; // Field-length norm: the shorter the field, the higher the weight.\n  // Set to 3 decimals to reduce index size.\n\n  function norm() {\n    var mantissa = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n    var cache = new Map();\n    return {\n      get: function get(value) {\n        var numTokens = value.match(SPACE).length;\n\n        if (cache.has(numTokens)) {\n          return cache.get(numTokens);\n        }\n\n        var n = parseFloat((1 / Math.sqrt(numTokens)).toFixed(mantissa));\n        cache.set(numTokens, n);\n        return n;\n      },\n      clear: function clear() {\n        cache.clear();\n      }\n    };\n  }\n\n  var FuseIndex = /*#__PURE__*/function () {\n    function FuseIndex() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$getFn = _ref.getFn,\n          getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn;\n\n      _classCallCheck(this, FuseIndex);\n\n      this.norm = norm(3);\n      this.getFn = getFn;\n      this.isCreated = false;\n      this.setRecords();\n    }\n\n    _createClass(FuseIndex, [{\n      key: \"setCollection\",\n      value: function setCollection() {\n        var docs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        this.docs = docs;\n      }\n    }, {\n      key: \"setRecords\",\n      value: function setRecords() {\n        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        this.records = records;\n      }\n    }, {\n      key: \"setKeys\",\n      value: function setKeys() {\n        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        this.keys = keys;\n      }\n    }, {\n      key: \"create\",\n      value: function create() {\n        var _this = this;\n\n        if (this.isCreated || !this.docs.length) {\n          return;\n        }\n\n        this.isCreated = true; // List is Array<String>\n\n        if (isString(this.docs[0])) {\n          this.docs.forEach(function (doc, docIndex) {\n            _this._addString(doc, docIndex);\n          });\n        } else {\n          // List is Array<Object>\n          this.docs.forEach(function (doc, docIndex) {\n            _this._addObject(doc, docIndex);\n          });\n        }\n\n        this.norm.clear();\n      } // Adds a doc to the end of the index\n\n    }, {\n      key: \"add\",\n      value: function add(doc) {\n        var idx = this.size();\n\n        if (isString(doc)) {\n          this._addString(doc, idx);\n        } else {\n          this._addObject(doc, idx);\n        }\n      } // Removes the doc at the specified index of the index\n\n    }, {\n      key: \"removeAt\",\n      value: function removeAt(idx) {\n        this.records.splice(idx, 1); // Change ref index of every subsquent doc\n\n        for (var i = idx, len = this.size(); i < len; i += 1) {\n          this.records[i].i -= 1;\n        }\n      }\n    }, {\n      key: \"size\",\n      value: function size() {\n        return this.records.length;\n      }\n    }, {\n      key: \"_addString\",\n      value: function _addString(doc, docIndex) {\n        if (!isDefined(doc) || isBlank(doc)) {\n          return;\n        }\n\n        var record = {\n          v: doc,\n          i: docIndex,\n          n: this.norm.get(doc)\n        };\n        this.records.push(record);\n      }\n    }, {\n      key: \"_addObject\",\n      value: function _addObject(doc, docIndex) {\n        var _this2 = this;\n\n        var record = {\n          i: docIndex,\n          $: {}\n        }; // Iterate over every key (i.e, path), and fetch the value at that key\n\n        this.keys.forEach(function (key, keyIndex) {\n          var value = _this2.getFn(doc, key);\n\n          if (!isDefined(value)) {\n            return;\n          }\n\n          if (isArray(value)) {\n            (function () {\n              var subRecords = [];\n              var stack = [{\n                nestedArrIndex: -1,\n                value: value\n              }];\n\n              while (stack.length) {\n                var _stack$pop = stack.pop(),\n                    nestedArrIndex = _stack$pop.nestedArrIndex,\n                    _value = _stack$pop.value;\n\n                if (!isDefined(_value)) {\n                  continue;\n                }\n\n                if (isString(_value) && !isBlank(_value)) {\n                  var subRecord = {\n                    v: _value,\n                    i: nestedArrIndex,\n                    n: _this2.norm.get(_value)\n                  };\n                  subRecords.push(subRecord);\n                } else if (isArray(_value)) {\n                  _value.forEach(function (item, k) {\n                    stack.push({\n                      nestedArrIndex: k,\n                      value: item\n                    });\n                  });\n                }\n              }\n\n              record.$[keyIndex] = subRecords;\n            })();\n          } else if (!isBlank(value)) {\n            var subRecord = {\n              v: value,\n              n: _this2.norm.get(value)\n            };\n            record.$[keyIndex] = subRecord;\n          }\n        });\n        this.records.push(record);\n      }\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          keys: this.keys,\n          records: this.records\n        };\n      }\n    }]);\n\n    return FuseIndex;\n  }();\n  function createIndex(keys, docs) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$getFn = _ref2.getFn,\n        getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn;\n\n    var myIndex = new FuseIndex({\n      getFn: getFn\n    });\n    myIndex.setKeys(keys);\n    myIndex.setCollection(docs);\n    myIndex.create();\n    return myIndex;\n  }\n  function parseIndex(data) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref3$getFn = _ref3.getFn,\n        getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn;\n\n    var keys = data.keys,\n        records = data.records;\n    var myIndex = new FuseIndex({\n      getFn: getFn\n    });\n    myIndex.setKeys(keys);\n    myIndex.setRecords(records);\n    return myIndex;\n  }\n\n  function transformMatches(result, data) {\n    var matches = result.matches;\n    data.matches = [];\n\n    if (!isDefined(matches)) {\n      return;\n    }\n\n    matches.forEach(function (match) {\n      if (!isDefined(match.indices) || !match.indices.length) {\n        return;\n      }\n\n      var indices = match.indices,\n          value = match.value;\n      var obj = {\n        indices: indices,\n        value: value\n      };\n\n      if (match.key) {\n        obj.key = match.key;\n      }\n\n      if (match.idx > -1) {\n        obj.refIndex = match.idx;\n      }\n\n      data.matches.push(obj);\n    });\n  }\n\n  function transformScore(result, data) {\n    data.score = result.score;\n  }\n\n  function computeScore(pattern) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$errors = _ref.errors,\n        errors = _ref$errors === void 0 ? 0 : _ref$errors,\n        _ref$currentLocation = _ref.currentLocation,\n        currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,\n        _ref$expectedLocation = _ref.expectedLocation,\n        expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === void 0 ? Config.distance : _ref$distance;\n\n    var accuracy = errors / pattern.length;\n    var proximity = Math.abs(expectedLocation - currentLocation);\n\n    if (!distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n\n    return accuracy + proximity / distance;\n  }\n\n  function convertMaskToIndices() {\n    var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Config.minMatchCharLength;\n    var indices = [];\n    var start = -1;\n    var end = -1;\n    var i = 0;\n\n    for (var len = matchmask.length; i < len; i += 1) {\n      var match = matchmask[i];\n\n      if (match && start === -1) {\n        start = i;\n      } else if (!match && start !== -1) {\n        end = i - 1;\n\n        if (end - start + 1 >= minMatchCharLength) {\n          indices.push([start, end]);\n        }\n\n        start = -1;\n      }\n    } // (i-1 - start) + 1 => i - start\n\n\n    if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n      indices.push([start, i - 1]);\n    }\n\n    return indices;\n  }\n\n  // Machine word size\n  var MAX_BITS = 32;\n\n  function search(text, pattern, patternAlphabet) {\n    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref$location = _ref.location,\n        location = _ref$location === void 0 ? Config.location : _ref$location,\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\n        _ref$threshold = _ref.threshold,\n        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\n        _ref$findAllMatches = _ref.findAllMatches,\n        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\n        _ref$minMatchCharLeng = _ref.minMatchCharLength,\n        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\n        _ref$includeMatches = _ref.includeMatches,\n        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches;\n\n    if (pattern.length > MAX_BITS) {\n      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n    }\n\n    var patternLen = pattern.length; // Set starting location at beginning text and initialize the alphabet.\n\n    var textLen = text.length; // Handle the case when location > text.length\n\n    var expectedLocation = Math.max(0, Math.min(location, textLen)); // Highest score beyond which we give up.\n\n    var currentThreshold = threshold; // Is there a nearby exact match? (speedup)\n\n    var bestLocation = expectedLocation; // A mask of the matches, used for building the indices\n\n    var matchMask = [];\n\n    if (includeMatches) {\n      for (var i = 0; i < textLen; i += 1) {\n        matchMask[i] = 0;\n      }\n    }\n\n    var index; // Get all exact matches, here for speed up\n\n    while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n      var score = computeScore(pattern, {\n        currentLocation: index,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n      currentThreshold = Math.min(score, currentThreshold);\n      bestLocation = index + patternLen;\n\n      if (includeMatches) {\n        var _i = 0;\n\n        while (_i < patternLen) {\n          matchMask[index + _i] = 1;\n          _i += 1;\n        }\n      }\n    } // Reset the best location\n\n\n    bestLocation = -1;\n    var lastBitArr = [];\n    var finalScore = 1;\n    var binMax = patternLen + textLen;\n    var mask = 1 << patternLen - 1;\n\n    for (var _i2 = 0; _i2 < patternLen; _i2 += 1) {\n      // Scan for the best match; each iteration allows for one more error.\n      // Run a binary search to determine how far from the match location we can stray\n      // at this error level.\n      var binMin = 0;\n      var binMid = binMax;\n\n      while (binMin < binMid) {\n        var _score2 = computeScore(pattern, {\n          errors: _i2,\n          currentLocation: expectedLocation + binMid,\n          expectedLocation: expectedLocation,\n          distance: distance\n        });\n\n        if (_score2 <= currentThreshold) {\n          binMin = binMid;\n        } else {\n          binMax = binMid;\n        }\n\n        binMid = Math.floor((binMax - binMin) / 2 + binMin);\n      } // Use the result from this iteration as the maximum for the next.\n\n\n      binMax = binMid;\n      var start = Math.max(1, expectedLocation - binMid + 1);\n      var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen; // Initialize the bit array\n\n      var bitArr = Array(finish + 2);\n      bitArr[finish + 1] = (1 << _i2) - 1;\n\n      for (var j = finish; j >= start; j -= 1) {\n        var currentLocation = j - 1;\n        var charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n        if (charMatch && includeMatches) {\n          matchMask[currentLocation] = 1;\n        } // First pass: exact match\n\n\n        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch; // Subsequent passes: fuzzy match\n\n        if (_i2 !== 0) {\n          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n        }\n\n        if (bitArr[j] & mask) {\n          finalScore = computeScore(pattern, {\n            errors: _i2,\n            currentLocation: currentLocation,\n            expectedLocation: expectedLocation,\n            distance: distance\n          }); // This match will almost certainly be better than any existing match.\n          // But check anyway.\n\n          if (finalScore <= currentThreshold) {\n            // Indeed it is\n            currentThreshold = finalScore;\n            bestLocation = currentLocation; // Already passed `loc`, downhill from here on in.\n\n            if (bestLocation <= expectedLocation) {\n              break;\n            } // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n\n\n            start = Math.max(1, 2 * expectedLocation - bestLocation);\n          }\n        }\n      } // No hope for a (better) match at greater error levels.\n\n\n      var _score = computeScore(pattern, {\n        errors: _i2 + 1,\n        currentLocation: expectedLocation,\n        expectedLocation: expectedLocation,\n        distance: distance\n      });\n\n      if (_score > currentThreshold) {\n        break;\n      }\n\n      lastBitArr = bitArr;\n    }\n\n    var result = {\n      isMatch: bestLocation >= 0,\n      // Count exact matches (those with a score of 0) to be \"almost\" exact\n      score: Math.max(0.001, finalScore)\n    };\n\n    if (includeMatches) {\n      result.indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    }\n\n    return result;\n  }\n\n  function createPatternAlphabet(pattern) {\n    var mask = {};\n\n    for (var i = 0, len = pattern.length; i < len; i += 1) {\n      var char = pattern.charAt(i);\n      mask[char] = (mask[char] || 0) | 1 << len - i - 1;\n    }\n\n    return mask;\n  }\n\n  var BitapSearch = /*#__PURE__*/function () {\n    function BitapSearch(pattern) {\n      var _this = this;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$location = _ref.location,\n          location = _ref$location === void 0 ? Config.location : _ref$location,\n          _ref$threshold = _ref.threshold,\n          threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\n          _ref$distance = _ref.distance,\n          distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\n          _ref$includeMatches = _ref.includeMatches,\n          includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\n          _ref$findAllMatches = _ref.findAllMatches,\n          findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\n          _ref$minMatchCharLeng = _ref.minMatchCharLength,\n          minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\n          _ref$isCaseSensitive = _ref.isCaseSensitive,\n          isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive;\n\n      _classCallCheck(this, BitapSearch);\n\n      this.options = {\n        location: location,\n        threshold: threshold,\n        distance: distance,\n        includeMatches: includeMatches,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength,\n        isCaseSensitive: isCaseSensitive\n      };\n      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n      this.chunks = [];\n\n      if (!this.pattern.length) {\n        return;\n      }\n\n      var addChunk = function addChunk(pattern, startIndex) {\n        _this.chunks.push({\n          pattern: pattern,\n          alphabet: createPatternAlphabet(pattern),\n          startIndex: startIndex\n        });\n      };\n\n      var len = this.pattern.length;\n\n      if (len > MAX_BITS) {\n        var i = 0;\n        var remainder = len % MAX_BITS;\n        var end = len - remainder;\n\n        while (i < end) {\n          addChunk(this.pattern.substr(i, MAX_BITS), i);\n          i += MAX_BITS;\n        }\n\n        if (remainder) {\n          var startIndex = len - MAX_BITS;\n          addChunk(this.pattern.substr(startIndex), startIndex);\n        }\n      } else {\n        addChunk(this.pattern, 0);\n      }\n    }\n\n    _createClass(BitapSearch, [{\n      key: \"searchIn\",\n      value: function searchIn(text) {\n        var _this$options = this.options,\n            isCaseSensitive = _this$options.isCaseSensitive,\n            includeMatches = _this$options.includeMatches;\n\n        if (!isCaseSensitive) {\n          text = text.toLowerCase();\n        } // Exact match\n\n\n        if (this.pattern === text) {\n          var _result = {\n            isMatch: true,\n            score: 0\n          };\n\n          if (includeMatches) {\n            _result.indices = [[0, text.length - 1]];\n          }\n\n          return _result;\n        } // Otherwise, use Bitap algorithm\n\n\n        var _this$options2 = this.options,\n            location = _this$options2.location,\n            distance = _this$options2.distance,\n            threshold = _this$options2.threshold,\n            findAllMatches = _this$options2.findAllMatches,\n            minMatchCharLength = _this$options2.minMatchCharLength;\n        var allIndices = [];\n        var totalScore = 0;\n        var hasMatches = false;\n        this.chunks.forEach(function (_ref2) {\n          var pattern = _ref2.pattern,\n              alphabet = _ref2.alphabet,\n              startIndex = _ref2.startIndex;\n\n          var _search = search(text, pattern, alphabet, {\n            location: location + startIndex,\n            distance: distance,\n            threshold: threshold,\n            findAllMatches: findAllMatches,\n            minMatchCharLength: minMatchCharLength,\n            includeMatches: includeMatches\n          }),\n              isMatch = _search.isMatch,\n              score = _search.score,\n              indices = _search.indices;\n\n          if (isMatch) {\n            hasMatches = true;\n          }\n\n          totalScore += score;\n\n          if (isMatch && indices) {\n            allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));\n          }\n        });\n        var result = {\n          isMatch: hasMatches,\n          score: hasMatches ? totalScore / this.chunks.length : 1\n        };\n\n        if (hasMatches && includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result;\n      }\n    }]);\n\n    return BitapSearch;\n  }();\n\n  var BaseMatch = /*#__PURE__*/function () {\n    function BaseMatch(pattern) {\n      _classCallCheck(this, BaseMatch);\n\n      this.pattern = pattern;\n    }\n\n    _createClass(BaseMatch, [{\n      key: \"search\",\n      value: function search()\n      /*text*/\n      {}\n    }], [{\n      key: \"isMultiMatch\",\n      value: function isMultiMatch(pattern) {\n        return getMatch(pattern, this.multiRegex);\n      }\n    }, {\n      key: \"isSingleMatch\",\n      value: function isSingleMatch(pattern) {\n        return getMatch(pattern, this.singleRegex);\n      }\n    }]);\n\n    return BaseMatch;\n  }();\n\n  function getMatch(pattern, exp) {\n    var matches = pattern.match(exp);\n    return matches ? matches[1] : null;\n  }\n\n  var ExactMatch = /*#__PURE__*/function (_BaseMatch) {\n    _inherits(ExactMatch, _BaseMatch);\n\n    var _super = _createSuper(ExactMatch);\n\n    function ExactMatch(pattern) {\n      _classCallCheck(this, ExactMatch);\n\n      return _super.call(this, pattern);\n    }\n\n    _createClass(ExactMatch, [{\n      key: \"search\",\n      value: function search(text) {\n        var location = 0;\n        var index;\n        var indices = [];\n        var patternLen = this.pattern.length; // Get all exact matches\n\n        while ((index = text.indexOf(this.pattern, location)) > -1) {\n          location = index + patternLen;\n          indices.push([index, location - 1]);\n        }\n\n        var isMatch = !!indices.length;\n        return {\n          isMatch: isMatch,\n          score: isMatch ? 1 : 0,\n          indices: indices\n        };\n      }\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'exact';\n      }\n    }, {\n      key: \"multiRegex\",\n      get: function get() {\n        return /^'\"(.*)\"$/;\n      }\n    }, {\n      key: \"singleRegex\",\n      get: function get() {\n        return /^'(.*)$/;\n      }\n    }]);\n\n    return ExactMatch;\n  }(BaseMatch);\n\n  var InverseExactMatch = /*#__PURE__*/function (_BaseMatch) {\n    _inherits(InverseExactMatch, _BaseMatch);\n\n    var _super = _createSuper(InverseExactMatch);\n\n    function InverseExactMatch(pattern) {\n      _classCallCheck(this, InverseExactMatch);\n\n      return _super.call(this, pattern);\n    }\n\n    _createClass(InverseExactMatch, [{\n      key: \"search\",\n      value: function search(text) {\n        var index = text.indexOf(this.pattern);\n        var isMatch = index === -1;\n        return {\n          isMatch: isMatch,\n          score: isMatch ? 0 : 1,\n          indices: [0, text.length - 1]\n        };\n      }\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'inverse-exact';\n      }\n    }, {\n      key: \"multiRegex\",\n      get: function get() {\n        return /^!\"(.*)\"$/;\n      }\n    }, {\n      key: \"singleRegex\",\n      get: function get() {\n        return /^!(.*)$/;\n      }\n    }]);\n\n    return InverseExactMatch;\n  }(BaseMatch);\n\n  var PrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {\n    _inherits(PrefixExactMatch, _BaseMatch);\n\n    var _super = _createSuper(PrefixExactMatch);\n\n    function PrefixExactMatch(pattern) {\n      _classCallCheck(this, PrefixExactMatch);\n\n      return _super.call(this, pattern);\n    }\n\n    _createClass(PrefixExactMatch, [{\n      key: \"search\",\n      value: function search(text) {\n        var isMatch = text.startsWith(this.pattern);\n        return {\n          isMatch: isMatch,\n          score: isMatch ? 0 : 1,\n          indices: [0, this.pattern.length - 1]\n        };\n      }\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'prefix-exact';\n      }\n    }, {\n      key: \"multiRegex\",\n      get: function get() {\n        return /^\\^\"(.*)\"$/;\n      }\n    }, {\n      key: \"singleRegex\",\n      get: function get() {\n        return /^\\^(.*)$/;\n      }\n    }]);\n\n    return PrefixExactMatch;\n  }(BaseMatch);\n\n  var InversePrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {\n    _inherits(InversePrefixExactMatch, _BaseMatch);\n\n    var _super = _createSuper(InversePrefixExactMatch);\n\n    function InversePrefixExactMatch(pattern) {\n      _classCallCheck(this, InversePrefixExactMatch);\n\n      return _super.call(this, pattern);\n    }\n\n    _createClass(InversePrefixExactMatch, [{\n      key: \"search\",\n      value: function search(text) {\n        var isMatch = !text.startsWith(this.pattern);\n        return {\n          isMatch: isMatch,\n          score: isMatch ? 0 : 1,\n          indices: [0, text.length - 1]\n        };\n      }\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'inverse-prefix-exact';\n      }\n    }, {\n      key: \"multiRegex\",\n      get: function get() {\n        return /^!\\^\"(.*)\"$/;\n      }\n    }, {\n      key: \"singleRegex\",\n      get: function get() {\n        return /^!\\^(.*)$/;\n      }\n    }]);\n\n    return InversePrefixExactMatch;\n  }(BaseMatch);\n\n  var SuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {\n    _inherits(SuffixExactMatch, _BaseMatch);\n\n    var _super = _createSuper(SuffixExactMatch);\n\n    function SuffixExactMatch(pattern) {\n      _classCallCheck(this, SuffixExactMatch);\n\n      return _super.call(this, pattern);\n    }\n\n    _createClass(SuffixExactMatch, [{\n      key: \"search\",\n      value: function search(text) {\n        var isMatch = text.endsWith(this.pattern);\n        return {\n          isMatch: isMatch,\n          score: isMatch ? 0 : 1,\n          indices: [text.length - this.pattern.length, text.length - 1]\n        };\n      }\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'suffix-exact';\n      }\n    }, {\n      key: \"multiRegex\",\n      get: function get() {\n        return /^\"(.*)\"\\$$/;\n      }\n    }, {\n      key: \"singleRegex\",\n      get: function get() {\n        return /^(.*)\\$$/;\n      }\n    }]);\n\n    return SuffixExactMatch;\n  }(BaseMatch);\n\n  var InverseSuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {\n    _inherits(InverseSuffixExactMatch, _BaseMatch);\n\n    var _super = _createSuper(InverseSuffixExactMatch);\n\n    function InverseSuffixExactMatch(pattern) {\n      _classCallCheck(this, InverseSuffixExactMatch);\n\n      return _super.call(this, pattern);\n    }\n\n    _createClass(InverseSuffixExactMatch, [{\n      key: \"search\",\n      value: function search(text) {\n        var isMatch = !text.endsWith(this.pattern);\n        return {\n          isMatch: isMatch,\n          score: isMatch ? 0 : 1,\n          indices: [0, text.length - 1]\n        };\n      }\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'inverse-suffix-exact';\n      }\n    }, {\n      key: \"multiRegex\",\n      get: function get() {\n        return /^!\"(.*)\"\\$$/;\n      }\n    }, {\n      key: \"singleRegex\",\n      get: function get() {\n        return /^!(.*)\\$$/;\n      }\n    }]);\n\n    return InverseSuffixExactMatch;\n  }(BaseMatch);\n\n  var FuzzyMatch = /*#__PURE__*/function (_BaseMatch) {\n    _inherits(FuzzyMatch, _BaseMatch);\n\n    var _super = _createSuper(FuzzyMatch);\n\n    function FuzzyMatch(pattern) {\n      var _this;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$location = _ref.location,\n          location = _ref$location === void 0 ? Config.location : _ref$location,\n          _ref$threshold = _ref.threshold,\n          threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\n          _ref$distance = _ref.distance,\n          distance = _ref$distance === void 0 ? Config.distance : _ref$distance,\n          _ref$includeMatches = _ref.includeMatches,\n          includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\n          _ref$findAllMatches = _ref.findAllMatches,\n          findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\n          _ref$minMatchCharLeng = _ref.minMatchCharLength,\n          minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\n          _ref$isCaseSensitive = _ref.isCaseSensitive,\n          isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive;\n\n      _classCallCheck(this, FuzzyMatch);\n\n      _this = _super.call(this, pattern);\n      _this._bitapSearch = new BitapSearch(pattern, {\n        location: location,\n        threshold: threshold,\n        distance: distance,\n        includeMatches: includeMatches,\n        findAllMatches: findAllMatches,\n        minMatchCharLength: minMatchCharLength,\n        isCaseSensitive: isCaseSensitive\n      });\n      return _this;\n    }\n\n    _createClass(FuzzyMatch, [{\n      key: \"search\",\n      value: function search(text) {\n        return this._bitapSearch.searchIn(text);\n      }\n    }], [{\n      key: \"type\",\n      get: function get() {\n        return 'fuzzy';\n      }\n    }, {\n      key: \"multiRegex\",\n      get: function get() {\n        return /^\"(.*)\"$/;\n      }\n    }, {\n      key: \"singleRegex\",\n      get: function get() {\n        return /^(.*)$/;\n      }\n    }]);\n\n    return FuzzyMatch;\n  }(BaseMatch);\n\n  var searchers = [ExactMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];\n  var searchersLen = searchers.length; // Regex to split by spaces, but keep anything in quotes together\n\n  var SPACE_RE = / +(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\n  var OR_TOKEN = '|'; // Return a 2D array representation of the query, for simpler parsing.\n  // Example:\n  // \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\n\n  function parseQuery(pattern) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return pattern.split(OR_TOKEN).map(function (item) {\n      var query = item.trim().split(SPACE_RE).filter(function (item) {\n        return item && !!item.trim();\n      });\n      var results = [];\n\n      for (var i = 0, len = query.length; i < len; i += 1) {\n        var queryItem = query[i]; // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n\n        var found = false;\n        var idx = -1;\n\n        while (!found && ++idx < searchersLen) {\n          var searcher = searchers[idx];\n          var token = searcher.isMultiMatch(queryItem);\n\n          if (token) {\n            results.push(new searcher(token, options));\n            found = true;\n          }\n        }\n\n        if (found) {\n          continue;\n        } // 2. Handle single query matches (i.e, once that are *not* quoted)\n\n\n        idx = -1;\n\n        while (++idx < searchersLen) {\n          var _searcher = searchers[idx];\n\n          var _token = _searcher.isSingleMatch(queryItem);\n\n          if (_token) {\n            results.push(new _searcher(_token, options));\n            break;\n          }\n        }\n      }\n\n      return results;\n    });\n  }\n\n  // to a singl match\n\n  var MultiMatchSet = new Set([FuzzyMatch.type, ExactMatch.type]);\n  /**\n   * Command-like searching\n   * ======================\n   *\n   * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n   * search in a given text.\n   *\n   * Search syntax:\n   *\n   * | Token       | Match type                 | Description                            |\n   * | ----------- | -------------------------- | -------------------------------------- |\n   * | `jscript`   | fuzzy-match                | Items that match `jscript`             |\n   * | `'python`   | exact-match                | Items that include `python`            |\n   * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n   * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n   * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n   * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n   * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n   *\n   * A single pipe character acts as an OR operator. For example, the following\n   * query matches entries that start with `core` and end with either`go`, `rb`,\n   * or`py`.\n   *\n   * ```\n   * ^core go$ | rb$ | py$\n   * ```\n   */\n\n  var ExtendedSearch = /*#__PURE__*/function () {\n    function ExtendedSearch(pattern) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$isCaseSensitive = _ref.isCaseSensitive,\n          isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,\n          _ref$includeMatches = _ref.includeMatches,\n          includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,\n          _ref$minMatchCharLeng = _ref.minMatchCharLength,\n          minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,\n          _ref$findAllMatches = _ref.findAllMatches,\n          findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,\n          _ref$location = _ref.location,\n          location = _ref$location === void 0 ? Config.location : _ref$location,\n          _ref$threshold = _ref.threshold,\n          threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,\n          _ref$distance = _ref.distance,\n          distance = _ref$distance === void 0 ? Config.distance : _ref$distance;\n\n      _classCallCheck(this, ExtendedSearch);\n\n      this.query = null;\n      this.options = {\n        isCaseSensitive: isCaseSensitive,\n        includeMatches: includeMatches,\n        minMatchCharLength: minMatchCharLength,\n        findAllMatches: findAllMatches,\n        location: location,\n        threshold: threshold,\n        distance: distance\n      };\n      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n      this.query = parseQuery(this.pattern, this.options);\n    }\n\n    _createClass(ExtendedSearch, [{\n      key: \"searchIn\",\n      value: function searchIn(text) {\n        var query = this.query;\n\n        if (!query) {\n          return {\n            isMatch: false,\n            score: 1\n          };\n        }\n\n        var _this$options = this.options,\n            includeMatches = _this$options.includeMatches,\n            isCaseSensitive = _this$options.isCaseSensitive;\n        text = isCaseSensitive ? text : text.toLowerCase();\n        var numMatches = 0;\n        var allIndices = [];\n        var totalScore = 0; // ORs\n\n        for (var i = 0, qLen = query.length; i < qLen; i += 1) {\n          var searchers = query[i]; // Reset indices\n\n          allIndices.length = 0;\n          numMatches = 0; // ANDs\n\n          for (var j = 0, pLen = searchers.length; j < pLen; j += 1) {\n            var searcher = searchers[j];\n\n            var _searcher$search = searcher.search(text),\n                isMatch = _searcher$search.isMatch,\n                indices = _searcher$search.indices,\n                score = _searcher$search.score;\n\n            if (isMatch) {\n              numMatches += 1;\n              totalScore += score;\n\n              if (includeMatches) {\n                var type = searcher.constructor.type;\n\n                if (MultiMatchSet.has(type)) {\n                  allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));\n                } else {\n                  allIndices.push(indices);\n                }\n              }\n            } else {\n              totalScore = 0;\n              numMatches = 0;\n              allIndices.length = 0;\n              break;\n            }\n          } // OR condition, so if TRUE, return\n\n\n          if (numMatches) {\n            var result = {\n              isMatch: true,\n              score: totalScore / numMatches\n            };\n\n            if (includeMatches) {\n              result.indices = allIndices;\n            }\n\n            return result;\n          }\n        } // Nothing was matched\n\n\n        return {\n          isMatch: false,\n          score: 1\n        };\n      }\n    }], [{\n      key: \"condition\",\n      value: function condition(_, options) {\n        return options.useExtendedSearch;\n      }\n    }]);\n\n    return ExtendedSearch;\n  }();\n\n  var registeredSearchers = [];\n  function register() {\n    registeredSearchers.push.apply(registeredSearchers, arguments);\n  }\n  function createSearcher(pattern, options) {\n    for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {\n      var searcherClass = registeredSearchers[i];\n\n      if (searcherClass.condition(pattern, options)) {\n        return new searcherClass(pattern, options);\n      }\n    }\n\n    return new BitapSearch(pattern, options);\n  }\n\n  var LogicalOperator = {\n    AND: '$and',\n    OR: '$or'\n  };\n\n  var isExpression = function isExpression(query) {\n    return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n  };\n\n  var isLeaf = function isLeaf(query) {\n    return !isArray(query) && isObject(query) && !isExpression(query);\n  };\n\n  var convertToExplicit = function convertToExplicit(query) {\n    return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function (key) {\n      return _defineProperty({}, key, query[key]);\n    }));\n  }; // When `auto` is `true`, the parse function will infer and initialize and add\n  // the appropriate `Searcher` instance\n\n\n  function parse(query, options) {\n    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref3$auto = _ref3.auto,\n        auto = _ref3$auto === void 0 ? true : _ref3$auto;\n\n    var next = function next(query) {\n      var keys = Object.keys(query);\n\n      if (keys.length > 1 && !isExpression(query)) {\n        return next(convertToExplicit(query));\n      }\n\n      var key = keys[0];\n\n      if (isLeaf(query)) {\n        var pattern = query[key];\n\n        if (!isString(pattern)) {\n          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n        }\n\n        var obj = {\n          key: key,\n          pattern: pattern\n        };\n\n        if (auto) {\n          obj.searcher = createSearcher(pattern, options);\n        }\n\n        return obj;\n      }\n\n      var node = {\n        children: [],\n        operator: key\n      };\n      keys.forEach(function (key) {\n        var value = query[key];\n\n        if (isArray(value)) {\n          value.forEach(function (item) {\n            node.children.push(next(item));\n          });\n        }\n      });\n      return node;\n    };\n\n    if (!isExpression(query)) {\n      query = convertToExplicit(query);\n    }\n\n    return next(query);\n  }\n\n  var Fuse = /*#__PURE__*/function () {\n    function Fuse(docs) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = arguments.length > 2 ? arguments[2] : undefined;\n\n      _classCallCheck(this, Fuse);\n\n      this.options = _objectSpread2({}, Config, {}, options);\n\n      if (this.options.useExtendedSearch && !true) {\n        throw new Error(EXTENDED_SEARCH_UNAVAILABLE);\n      }\n\n      this._keyStore = new KeyStore(this.options.keys);\n      this.setCollection(docs, index);\n    }\n\n    _createClass(Fuse, [{\n      key: \"setCollection\",\n      value: function setCollection(docs, index) {\n        this._docs = docs;\n\n        if (index && !(index instanceof FuseIndex)) {\n          throw new Error(INCORRECT_INDEX_TYPE);\n        }\n\n        this._myIndex = index || createIndex(this._keyStore.keys(), this._docs, {\n          getFn: this.options.getFn\n        });\n      }\n    }, {\n      key: \"add\",\n      value: function add(doc) {\n        if (!isDefined(doc)) {\n          return;\n        }\n\n        this._docs.push(doc);\n\n        this._myIndex.add(doc);\n      }\n    }, {\n      key: \"removeAt\",\n      value: function removeAt(idx) {\n        this._docs.splice(idx, 1);\n\n        this._myIndex.removeAt(idx);\n      }\n    }, {\n      key: \"getIndex\",\n      value: function getIndex() {\n        return this._myIndex;\n      }\n    }, {\n      key: \"search\",\n      value: function search(query) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n            _ref$limit = _ref.limit,\n            limit = _ref$limit === void 0 ? -1 : _ref$limit;\n\n        var _this$options = this.options,\n            includeMatches = _this$options.includeMatches,\n            includeScore = _this$options.includeScore,\n            shouldSort = _this$options.shouldSort,\n            sortFn = _this$options.sortFn;\n        var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n        computeScore$1(results, this._keyStore);\n\n        if (shouldSort) {\n          results.sort(sortFn);\n        }\n\n        if (isNumber(limit) && limit > -1) {\n          results = results.slice(0, limit);\n        }\n\n        return format(results, this._docs, {\n          includeMatches: includeMatches,\n          includeScore: includeScore\n        });\n      }\n    }, {\n      key: \"_searchStringList\",\n      value: function _searchStringList(query) {\n        var searcher = createSearcher(query, this.options);\n        var records = this._myIndex.records;\n        var results = []; // Iterate over every string in the index\n\n        records.forEach(function (_ref2) {\n          var text = _ref2.v,\n              idx = _ref2.i,\n              norm = _ref2.n;\n\n          if (!isDefined(text)) {\n            return;\n          }\n\n          var _searcher$searchIn = searcher.searchIn(text),\n              isMatch = _searcher$searchIn.isMatch,\n              score = _searcher$searchIn.score,\n              indices = _searcher$searchIn.indices;\n\n          if (isMatch) {\n            results.push({\n              item: text,\n              idx: idx,\n              matches: [{\n                score: score,\n                value: text,\n                norm: norm,\n                indices: indices\n              }]\n            });\n          }\n        });\n        return results;\n      }\n    }, {\n      key: \"_searchLogical\",\n      value: function _searchLogical(query) {\n        var _this = this;\n\n        var expression = parse(query, this.options);\n        var _this$_myIndex = this._myIndex,\n            keys = _this$_myIndex.keys,\n            records = _this$_myIndex.records;\n        var resultMap = {};\n        var results = [];\n\n        var evaluateExpression = function evaluateExpression(node, item, idx) {\n          if (node.children) {\n            var operator = node.operator;\n            var res = [];\n\n            for (var k = 0; k < node.children.length; k += 1) {\n              var child = node.children[k];\n              var matches = evaluateExpression(child, item, idx);\n\n              if (matches && matches.length) {\n                res.push({\n                  idx: idx,\n                  item: item,\n                  matches: matches\n                });\n\n                if (operator === LogicalOperator.OR) {\n                  // Short-circuit\n                  break;\n                }\n              } else if (operator === LogicalOperator.AND) {\n                res.length = 0; // Short-circuit\n\n                break;\n              }\n            }\n\n            if (res.length) {\n              // Dedupe when adding\n              if (!resultMap[idx]) {\n                resultMap[idx] = {\n                  idx: idx,\n                  item: item,\n                  matches: []\n                };\n                results.push(resultMap[idx]);\n              }\n\n              res.forEach(function (_ref3) {\n                var _resultMap$idx$matche;\n\n                var matches = _ref3.matches;\n\n                (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));\n              });\n            }\n          } else {\n            var key = node.key,\n                searcher = node.searcher;\n            var value = item[keys.indexOf(key)];\n            return _this._findMatches({\n              key: key,\n              value: value,\n              searcher: searcher\n            });\n          }\n        };\n\n        records.forEach(function (_ref4) {\n          var item = _ref4.$,\n              idx = _ref4.i;\n\n          if (isDefined(item)) {\n            evaluateExpression(expression, item, idx);\n          }\n        });\n        return results;\n      }\n    }, {\n      key: \"_searchObjectList\",\n      value: function _searchObjectList(query) {\n        var _this2 = this;\n\n        var searcher = createSearcher(query, this.options);\n        var _this$_myIndex2 = this._myIndex,\n            keys = _this$_myIndex2.keys,\n            records = _this$_myIndex2.records;\n        var results = []; // List is Array<Object>\n\n        records.forEach(function (_ref5) {\n          var item = _ref5.$,\n              idx = _ref5.i;\n\n          if (!isDefined(item)) {\n            return;\n          }\n\n          var matches = []; // Iterate over every key (i.e, path), and fetch the value at that key\n\n          keys.forEach(function (key, keyIndex) {\n            matches.push.apply(matches, _toConsumableArray(_this2._findMatches({\n              key: key,\n              value: item[keyIndex],\n              searcher: searcher\n            })));\n          });\n\n          if (matches.length) {\n            results.push({\n              idx: idx,\n              item: item,\n              matches: matches\n            });\n          }\n        });\n        return results;\n      }\n    }, {\n      key: \"_findMatches\",\n      value: function _findMatches(_ref6) {\n        var key = _ref6.key,\n            value = _ref6.value,\n            searcher = _ref6.searcher;\n\n        if (!isDefined(value)) {\n          return [];\n        }\n\n        var matches = [];\n\n        if (isArray(value)) {\n          value.forEach(function (_ref7) {\n            var text = _ref7.v,\n                idx = _ref7.i,\n                norm = _ref7.n;\n\n            if (!isDefined(text)) {\n              return;\n            }\n\n            var _searcher$searchIn2 = searcher.searchIn(text),\n                isMatch = _searcher$searchIn2.isMatch,\n                score = _searcher$searchIn2.score,\n                indices = _searcher$searchIn2.indices;\n\n            if (isMatch) {\n              matches.push({\n                score: score,\n                key: key,\n                value: text,\n                idx: idx,\n                norm: norm,\n                indices: indices\n              });\n            }\n          });\n        } else {\n          var text = value.v,\n              norm = value.n;\n\n          var _searcher$searchIn3 = searcher.searchIn(text),\n              isMatch = _searcher$searchIn3.isMatch,\n              score = _searcher$searchIn3.score,\n              indices = _searcher$searchIn3.indices;\n\n          if (isMatch) {\n            matches.push({\n              score: score,\n              key: key,\n              value: text,\n              norm: norm,\n              indices: indices\n            });\n          }\n        }\n\n        return matches;\n      }\n    }]);\n\n    return Fuse;\n  }(); // Practical scoring function\n\n  function computeScore$1(results, keyStore) {\n    results.forEach(function (result) {\n      var totalScore = 1;\n      result.matches.forEach(function (_ref8) {\n        var key = _ref8.key,\n            norm = _ref8.norm,\n            score = _ref8.score;\n        var weight = keyStore.get(key, 'weight');\n        totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * norm);\n      });\n      result.score = totalScore;\n    });\n  }\n\n  function format(results, docs) {\n    var _ref9 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref9$includeMatches = _ref9.includeMatches,\n        includeMatches = _ref9$includeMatches === void 0 ? Config.includeMatches : _ref9$includeMatches,\n        _ref9$includeScore = _ref9.includeScore,\n        includeScore = _ref9$includeScore === void 0 ? Config.includeScore : _ref9$includeScore;\n\n    var transformers = [];\n    if (includeMatches) transformers.push(transformMatches);\n    if (includeScore) transformers.push(transformScore);\n    return results.map(function (result) {\n      var idx = result.idx;\n      var data = {\n        item: docs[idx],\n        refIndex: idx\n      };\n\n      if (transformers.length) {\n        transformers.forEach(function (transformer) {\n          transformer(result, data);\n        });\n      }\n\n      return data;\n    });\n  }\n\n  Fuse.version = '6.0.4';\n  Fuse.createIndex = createIndex;\n  Fuse.parseIndex = parseIndex;\n  Fuse.config = Config;\n\n  {\n    Fuse.parseQuery = parse;\n  }\n\n  {\n    register(ExtendedSearch);\n  }\n\n  return Fuse;\n\n})));\n"],"sourceRoot":"webpack:///"}